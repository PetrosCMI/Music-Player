<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Player v1.1</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .touch-manipulation {
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            background: #4b5563;
            border-radius: 5px;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #9333ea;
            cursor: pointer;
            border-radius: 50%;
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #9333ea;
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }
    </style>
</head>
<body class="min-h-screen bg-gradient-to-br from-gray-900 via-purple-900 to-gray-900 p-4">
    <div class="max-w-2xl mx-auto">
        <div class="bg-gray-800 rounded-lg shadow-2xl p-6">
            <h1 class="text-2xl md:text-3xl font-bold text-white mb-4 text-center">
                Audio Player <span class="text-sm text-gray-400">v1.1</span>
            </h1>

            <!-- Current Track Info -->
            <div class="bg-gray-700 rounded-lg p-4 mb-4">
                <div class="text-center">
                    <p class="text-gray-400 text-sm mb-1">Now Playing</p>
                    <p id="currentTrackName" class="text-white font-semibold truncate text-sm md:text-base">
                        No track selected
                    </p>
                    <p id="trackPosition" class="text-gray-400 text-xs mt-1"></p>
                </div>
            </div>

            <!-- Progress Bar -->
            <div class="mb-4">
                <div id="progressBar" class="bg-gray-700 h-3 rounded-full cursor-pointer touch-manipulation">
                    <div id="progressFill" class="bg-purple-500 h-3 rounded-full transition-all" style="width: 0%"></div>
                </div>
                <div class="flex justify-between text-gray-400 text-sm mt-2">
                    <span id="currentTime">0:00</span>
                    <span id="duration">0:00</span>
                </div>
            </div>

            <!-- Playback Speed -->
            <div class="mb-4">
                <label class="text-gray-300 text-sm mb-2 block">
                    Speed: <span id="speedDisplay">1.0</span>x
                </label>
                <div class="flex items-center gap-2">
                    <button id="speedDown" class="bg-gray-700 text-white px-3 py-2 rounded hover:bg-gray-600 active:bg-gray-500 text-sm touch-manipulation">
                        -0.1
                    </button>
                    <input id="speedSlider" type="range" min="0.1" max="3.0" step="0.1" value="1.0" class="flex-1 touch-manipulation">
                    <button id="speedUp" class="bg-gray-700 text-white px-3 py-2 rounded hover:bg-gray-600 active:bg-gray-500 text-sm touch-manipulation">
                        +0.1
                    </button>
                </div>
            </div>

            <!-- Main Controls -->
            <div class="flex justify-center items-center gap-3 mb-4">
                <button id="prevBtn" class="bg-gray-700 p-3 rounded-full hover:bg-gray-600 active:bg-gray-500 transition touch-manipulation" title="Previous Track">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-white"><polygon points="19 20 9 12 19 4 19 20"></polygon><line x1="5" y1="19" x2="5" y2="5"></line></svg>
                </button>
                
                <button id="playPauseBtn" class="bg-purple-600 p-4 rounded-full hover:bg-purple-700 active:bg-purple-800 transition touch-manipulation" title="Play/Pause">
                    <svg id="playIcon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-white"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
                    <svg id="pauseIcon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-white hidden"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>
                </button>
                
                <button id="skipBtn" class="bg-gray-700 p-3 rounded-full hover:bg-gray-600 active:bg-gray-500 transition touch-manipulation" title="Skip Forward 60s">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-white"><polygon points="5 4 15 12 5 20 5 4"></polygon><line x1="19" y1="5" x2="19" y2="19"></line></svg>
                </button>

                <button id="loopBtn" class="bg-gray-700 p-3 rounded-full hover:bg-gray-600 transition touch-manipulation" title="Loop: none">
                    <svg id="loopIcon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-white"><polyline points="17 1 21 5 17 9"></polyline><path d="M3 11V9a4 4 0 0 1 4-4h14"></path><polyline points="7 23 3 19 7 15"></polyline><path d="M21 13v2a4 4 0 0 1-4 4H3"></path></svg>
                    <svg id="loop1Icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-white hidden"><polyline points="17 1 21 5 17 9"></polyline><path d="M3 11V9a4 4 0 0 1 4-4h14"></path><polyline points="7 23 3 19 7 15"></polyline><path d="M21 13v2a4 4 0 0 1-4 4H3"></path><line x1="11" y1="10" x2="11" y2="14"></line></svg>
                </button>
            </div>

            <!-- Playlist Management -->
            <div class="flex gap-2 mb-4">
                <input type="file" id="fileInput" accept="audio/*" multiple class="hidden">
                <label for="fileInput" class="flex-1 bg-purple-600 text-white py-3 rounded-lg cursor-pointer hover:bg-purple-700 active:bg-purple-800 transition flex items-center justify-center gap-2 text-sm md:text-base touch-manipulation">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
                    Add Tracks
                </label>
                <button id="clearBtn" class="bg-red-600 text-white px-4 md:px-6 py-3 rounded-lg hover:bg-red-700 active:bg-red-800 transition flex items-center gap-2 text-sm md:text-base touch-manipulation">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
                    Clear
                </button>
            </div>

            <!-- Playlist -->
            <div class="bg-gray-700 rounded-lg p-4 max-h-64 overflow-y-auto">
                <h3 class="text-white font-semibold mb-3 text-sm md:text-base">
                    Playlist (<span id="playlistCount">0</span>)
                </h3>
                <div id="playlistContainer">
                    <p class="text-gray-400 text-center py-4 text-sm">No tracks in playlist</p>
                </div>
            </div>
        </div>
    </div>

    <audio id="audioPlayer" preload="metadata"></audio>

    <script>
        // State
        let playlist = [];
        let currentIndex = 0;
        let isPlaying = false;
        let playbackRate = 1.0;
        let loopMode = 'none'; // 'none', 'one', 'all'
        let wakeLock = null;

        // Elements
        const audio = document.getElementById('audioPlayer');
        const fileInput = document.getElementById('fileInput');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const playIcon = document.getElementById('playIcon');
        const pauseIcon = document.getElementById('pauseIcon');
        const prevBtn = document.getElementById('prevBtn');
        const skipBtn = document.getElementById('skipBtn');
        const loopBtn = document.getElementById('loopBtn');
        const loopIcon = document.getElementById('loopIcon');
        const loop1Icon = document.getElementById('loop1Icon');
        const clearBtn = document.getElementById('clearBtn');
        const progressBar = document.getElementById('progressBar');
        const progressFill = document.getElementById('progressFill');
        const currentTimeEl = document.getElementById('currentTime');
        const durationEl = document.getElementById('duration');
        const currentTrackName = document.getElementById('currentTrackName');
        const trackPosition = document.getElementById('trackPosition');
        const speedSlider = document.getElementById('speedSlider');
        const speedDisplay = document.getElementById('speedDisplay');
        const speedUp = document.getElementById('speedUp');
        const speedDown = document.getElementById('speedDown');
        const playlistContainer = document.getElementById('playlistContainer');
        const playlistCount = document.getElementById('playlistCount');

        // Format time
        function formatTime(seconds) {
            if (isNaN(seconds) || seconds === 0) return '0:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // Update UI
        function updateUI() {
            if (playlist.length > 0) {
                currentTrackName.textContent = playlist[currentIndex].name;
                trackPosition.textContent = `Track ${currentIndex + 1} of ${playlist.length}`;
            } else {
                currentTrackName.textContent = 'No track selected';
                trackPosition.textContent = '';
            }
            playlistCount.textContent = playlist.length;
        }

        // Render playlist
        function renderPlaylist() {
            if (playlist.length === 0) {
                playlistContainer.innerHTML = '<p class="text-gray-400 text-center py-4 text-sm">No tracks in playlist</p>';
            } else {
                playlistContainer.innerHTML = playlist.map((track, idx) => `
                    <div data-index="${idx}" class="playlist-item p-2 rounded cursor-pointer transition touch-manipulation text-sm ${idx === currentIndex ? 'bg-purple-600 text-white' : 'bg-gray-600 text-gray-200 hover:bg-gray-500 active:bg-gray-400'} mb-2">
                        ${idx + 1}. ${track.name}
                    </div>
                `).join('');

                document.querySelectorAll('.playlist-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const idx = parseInt(item.dataset.index);
                        selectTrack(idx);
                    });
                });
            }
        }

        // Wake lock
        async function requestWakeLock() {
            if ('wakeLock' in navigator) {
                try {
                    wakeLock = await navigator.wakeLock.request('screen');
                } catch (err) {
                    console.log('Wake lock error:', err);
                }
            }
        }

        function releaseWakeLock() {
            if (wakeLock) {
                wakeLock.release();
                wakeLock = null;
            }
        }

        // Media Session
        function updateMediaSession() {
            if ('mediaSession' in navigator && playlist.length > 0) {
                navigator.mediaSession.metadata = new MediaMetadata({
                    title: playlist[currentIndex].name,
                    artist: 'Audio Player',
                    album: `Track ${currentIndex + 1} of ${playlist.length}`
                });

                navigator.mediaSession.setActionHandler('play', togglePlayPause);
                navigator.mediaSession.setActionHandler('pause', togglePlayPause);
                navigator.mediaSession.setActionHandler('seekforward', () => skipForward(60));
                navigator.mediaSession.setActionHandler('seekbackward', () => skipForward(-10));
                navigator.mediaSession.setActionHandler('previoustrack', previousTrack);
                // Map nexttrack to skip forward instead of next track
                navigator.mediaSession.setActionHandler('nexttrack', () => skipForward(60));

                if (audio.duration > 0) {
                    navigator.mediaSession.setPositionState({
                        duration: audio.duration,
                        playbackRate: playbackRate,
                        position: audio.currentTime
                    });
                }
            }
        }

        // Load track
        function loadTrack(index) {
            if (playlist.length === 0) return;
            currentIndex = index;
            const wasPlaying = isPlaying;
            
            audio.src = playlist[currentIndex].url;
            audio.playbackRate = playbackRate;
            audio.load();
            
            updateUI();
            renderPlaylist();
            updateMediaSession();
            
            if (wasPlaying) {
                audio.play().catch(err => {
                    console.log('Play error:', err);
                    isPlaying = false;
                    updatePlayPauseButton();
                });
            }
        }

        // Toggle play/pause
        function togglePlayPause() {
            if (playlist.length === 0) return;

            if (isPlaying) {
                audio.pause();
                isPlaying = false;
                releaseWakeLock();
                if ('mediaSession' in navigator) {
                    navigator.mediaSession.playbackState = 'paused';
                }
            } else {
                audio.play().then(() => {
                    isPlaying = true;
                    requestWakeLock();
                    if ('mediaSession' in navigator) {
                        navigator.mediaSession.playbackState = 'playing';
                    }
                    updatePlayPauseButton();
                }).catch(err => {
                    console.log('Play error:', err);
                    isPlaying = false;
                    updatePlayPauseButton();
                });
            }
            updatePlayPauseButton();
        }

        function updatePlayPauseButton() {
            if (isPlaying) {
                playIcon.classList.add('hidden');
                pauseIcon.classList.remove('hidden');
            } else {
                playIcon.classList.remove('hidden');
                pauseIcon.classList.add('hidden');
            }
        }

        // Skip forward
        function skipForward(seconds) {
            if (audio.duration > 0) {
                audio.currentTime = Math.min(audio.currentTime + seconds, audio.duration);
            }
        }

        // Previous track
        function previousTrack() {
            if (playlist.length === 0) return;
            const newIndex = currentIndex > 0 ? currentIndex - 1 : playlist.length - 1;
            loadTrack(newIndex);
        }

        // Next track
        function nextTrack() {
            if (playlist.length === 0) return;
            const newIndex = (currentIndex + 1) % playlist.length;
            loadTrack(newIndex);
        }

        // Select track
        function selectTrack(index) {
            loadTrack(index);
        }

        // Loop mode
        function cycleLoopMode() {
            const modes = ['none', 'one', 'all'];
            const currentIdx = modes.indexOf(loopMode);
            loopMode = modes[(currentIdx + 1) % modes.length];
            
            if (loopMode === 'none') {
                loopBtn.classList.remove('bg-purple-600');
                loopBtn.classList.add('bg-gray-700');
                loopIcon.classList.remove('hidden');
                loop1Icon.classList.add('hidden');
            } else if (loopMode === 'one') {
                loopBtn.classList.add('bg-purple-600');
                loopBtn.classList.remove('bg-gray-700');
                loopIcon.classList.add('hidden');
                loop1Icon.classList.remove('hidden');
            } else {
                loopBtn.classList.add('bg-purple-600');
                loopBtn.classList.remove('bg-gray-700');
                loopIcon.classList.remove('hidden');
                loop1Icon.classList.add('hidden');
            }
            loopBtn.title = `Loop: ${loopMode}`;
        }

        // File input
        fileInput.addEventListener('change', (e) => {
            const files = Array.from(e.target.files);
            files.forEach(file => {
                playlist.push({
                    name: file.name,
                    url: URL.createObjectURL(file)
                });
            });
            
            if (playlist.length === files.length) {
                loadTrack(0);
            } else {
                updateUI();
                renderPlaylist();
            }
            
            fileInput.value = '';
        });

        // Clear playlist
        clearBtn.addEventListener('click', () => {
            audio.pause();
            audio.src = '';
            playlist.forEach(track => URL.revokeObjectURL(track.url));
            playlist = [];
            currentIndex = 0;
            isPlaying = false;
            releaseWakeLock();
            updateUI();
            renderPlaylist();
            updatePlayPauseButton();
            progressFill.style.width = '0%';
            currentTimeEl.textContent = '0:00';
            durationEl.textContent = '0:00';
        });

        // Controls
        playPauseBtn.addEventListener('click', togglePlayPause);
        prevBtn.addEventListener('click', previousTrack);
        skipBtn.addEventListener('click', () => skipForward(60));
        loopBtn.addEventListener('click', cycleLoopMode);

        // Progress bar
        progressBar.addEventListener('click', (e) => {
            if (audio.duration > 0) {
                const rect = progressBar.getBoundingClientRect();
                const percent = (e.clientX - rect.left) / rect.width;
                audio.currentTime = percent * audio.duration;
            }
        });

        // Speed controls
        speedSlider.addEventListener('input', (e) => {
            playbackRate = parseFloat(e.target.value);
            audio.playbackRate = playbackRate;
            speedDisplay.textContent = playbackRate.toFixed(1);
        });

        speedUp.addEventListener('click', () => {
            playbackRate = Math.min(3.0, Math.round((playbackRate + 0.1) * 10) / 10);
            speedSlider.value = playbackRate;
            audio.playbackRate = playbackRate;
            speedDisplay.textContent = playbackRate.toFixed(1);
        });

        speedDown.addEventListener('click', () => {
            playbackRate = Math.max(0.1, Math.round((playbackRate - 0.1) * 10) / 10);
            speedSlider.value = playbackRate;
            audio.playbackRate = playbackRate;
            speedDisplay.textContent = playbackRate.toFixed(1);
        });

        // Audio events
        audio.addEventListener('timeupdate', () => {
            currentTimeEl.textContent = formatTime(audio.currentTime);
            if (audio.duration > 0) {
                progressFill.style.width = `${(audio.currentTime / audio.duration) * 100}%`;
            }
            // Keep media session updated
            updateMediaSession();
        });

        audio.addEventListener('loadedmetadata', () => {
            durationEl.textContent = formatTime(audio.duration);
            updateMediaSession();
        });

        audio.addEventListener('play', () => {
            isPlaying = true;
            updatePlayPauseButton();
            if ('mediaSession' in navigator) {
                navigator.mediaSession.playbackState = 'playing';
            }
        });

        audio.addEventListener('pause', () => {
            isPlaying = false;
            updatePlayPauseButton();
            if ('mediaSession' in navigator) {
                navigator.mediaSession.playbackState = 'paused';
            }
        });

        audio.addEventListener('ended', () => {
            if (loopMode === 'one') {
                audio.currentTime = 0;
                audio.play();
            } else if (loopMode === 'all') {
                nextTrack();
            } else if (currentIndex < playlist.length - 1) {
                nextTrack();
            } else {
                isPlaying = false;
                updatePlayPauseButton();
                releaseWakeLock();
            }
        });
    </script>
</body>
</html>
