import React, { useState, useRef, useEffect } from 'react';
import { Play, Pause, SkipForward, SkipBack, Plus, Trash2, Repeat, Repeat1 } from 'lucide-react';

export default function AudioPlayer() {
  const [playlist, setPlaylist] = useState([]);
  const [currentIndex, setCurrentIndex] = useState(0);
  const [isPlaying, setIsPlaying] = useState(false);
  const [currentTime, setCurrentTime] = useState(0);
  const [duration, setDuration] = useState(0);
  const [playbackRate, setPlaybackRate] = useState(1.0);
  const [loopMode, setLoopMode] = useState('none'); // 'none', 'one', 'all'
  
  const audioRef = useRef(null);
  const fileInputRef = useRef(null);

  // Initialize audio element and wake lock
  useEffect(() => {
    const audio = new Audio();
    audio.preload = 'metadata';
    audioRef.current = audio;

    // Request wake lock to keep playing when screen is off
    let wakeLock = null;
    const requestWakeLock = async () => {
      try {
        if ('wakeLock' in navigator) {
          wakeLock = await navigator.wakeLock.request('screen');
        }
      } catch (err) {
        console.log('Wake lock not supported or denied');
      }
    };
    requestWakeLock();

    // Event listeners
    const handleTimeUpdate = () => setCurrentTime(audio.currentTime);
    const handleLoadedMetadata = () => setDuration(audio.duration);
    const handleEnded = () => handleTrackEnd();

    audio.addEventListener('timeupdate', handleTimeUpdate);
    audio.addEventListener('loadedmetadata', handleLoadedMetadata);
    audio.addEventListener('ended', handleEnded);

    return () => {
      audio.removeEventListener('timeupdate', handleTimeUpdate);
      audio.removeEventListener('loadedmetadata', handleLoadedMetadata);
      audio.removeEventListener('ended', handleEnded);
      if (wakeLock) wakeLock.release();
      audio.pause();
    };
  }, []);

  // Setup Media Session API for headset controls
  useEffect(() => {
    if ('mediaSession' in navigator && playlist.length > 0) {
      const currentTrack = playlist[currentIndex];
      navigator.mediaSession.metadata = new MediaMetadata({
        title: currentTrack?.name || 'Unknown Track',
        artist: 'Audio Player',
        album: `Track ${currentIndex + 1} of ${playlist.length}`
      });

      navigator.mediaSession.setActionHandler('play', () => togglePlayPause());
      navigator.mediaSession.setActionHandler('pause', () => togglePlayPause());
      navigator.mediaSession.setActionHandler('seekforward', () => skipForward());
      navigator.mediaSession.setActionHandler('previoustrack', () => previousTrack());
      navigator.mediaSession.setActionHandler('nexttrack', () => skipForward());
    }
  }, [playlist, currentIndex, isPlaying]);

  // Load and play track
  useEffect(() => {
    if (playlist.length > 0 && audioRef.current) {
      const track = playlist[currentIndex];
      audioRef.current.src = track.url;
      audioRef.current.playbackRate = playbackRate;
      
      if (isPlaying) {
        audioRef.current.play().catch(err => console.log('Play failed:', err));
      }
    }
  }, [currentIndex, playlist]);

  // Update playback rate
  useEffect(() => {
    if (audioRef.current) {
      audioRef.current.playbackRate = playbackRate;
    }
  }, [playbackRate]);

  const handleFileSelect = (e) => {
    const files = Array.from(e.target.files);
    const newTracks = files.map(file => ({
      name: file.name,
      url: URL.createObjectURL(file),
      file: file
    }));
    setPlaylist(prev => [...prev, ...newTracks]);
    if (fileInputRef.current) fileInputRef.current.value = '';
  };

  const togglePlayPause = () => {
    if (!audioRef.current || playlist.length === 0) return;
    
    if (isPlaying) {
      audioRef.current.pause();
      setIsPlaying(false);
    } else {
      audioRef.current.play().catch(err => console.log('Play failed:', err));
      setIsPlaying(true);
    }
  };

  const skipForward = () => {
    if (audioRef.current) {
      audioRef.current.currentTime = Math.min(audioRef.current.currentTime + 60, duration);
    }
  };

  const previousTrack = () => {
    if (playlist.length === 0) return;
    const newIndex = currentIndex > 0 ? currentIndex - 1 : playlist.length - 1;
    setCurrentIndex(newIndex);
    setCurrentTime(0);
  };

  const handleTrackEnd = () => {
    if (loopMode === 'one') {
      audioRef.current.currentTime = 0;
      audioRef.current.play();
    } else if (loopMode === 'all') {
      const newIndex = (currentIndex + 1) % playlist.length;
      setCurrentIndex(newIndex);
    } else if (currentIndex < playlist.length - 1) {
      setCurrentIndex(currentIndex + 1);
    } else {
      setIsPlaying(false);
    }
  };

  const clearPlaylist = () => {
    if (audioRef.current) {
      audioRef.current.pause();
      audioRef.current.src = '';
    }
    playlist.forEach(track => URL.revokeObjectURL(track.url));
    setPlaylist([]);
    setCurrentIndex(0);
    setIsPlaying(false);
    setCurrentTime(0);
    setDuration(0);
  };

  const seekTo = (e) => {
    const rect = e.currentTarget.getBoundingClientRect();
    const percent = (e.clientX - rect.left) / rect.width;
    const newTime = percent * duration;
    if (audioRef.current) {
      audioRef.current.currentTime = newTime;
      setCurrentTime(newTime);
    }
  };

  const cycleLoopMode = () => {
    const modes = ['none', 'one', 'all'];
    const currentIdx = modes.indexOf(loopMode);
    setLoopMode(modes[(currentIdx + 1) % modes.length]);
  };

  const formatTime = (seconds) => {
    if (isNaN(seconds)) return '0:00';
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  const adjustPlaybackRate = (delta) => {
    setPlaybackRate(prev => Math.max(0.1, Math.min(3.0, prev + delta)));
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-900 via-purple-900 to-gray-900 p-6">
      <div className="max-w-2xl mx-auto">
        <div className="bg-gray-800 rounded-lg shadow-2xl p-8">
          <h1 className="text-3xl font-bold text-white mb-6 text-center">
            Audio Player <span className="text-sm text-gray-400">v1.0</span>
          </h1>

          {/* Current Track Info */}
          <div className="bg-gray-700 rounded-lg p-4 mb-6">
            <div className="text-center">
              <p className="text-gray-400 text-sm mb-1">Now Playing</p>
              <p className="text-white font-semibold truncate">
                {playlist[currentIndex]?.name || 'No track selected'}
              </p>
              <p className="text-gray-400 text-xs mt-1">
                {playlist.length > 0 && `Track ${currentIndex + 1} of ${playlist.length}`}
              </p>
            </div>
          </div>

          {/* Progress Bar */}
          <div className="mb-6">
            <div 
              className="bg-gray-700 h-2 rounded-full cursor-pointer"
              onClick={seekTo}
            >
              <div 
                className="bg-purple-500 h-2 rounded-full transition-all"
                style={{ width: `${duration ? (currentTime / duration) * 100 : 0}%` }}
              />
            </div>
            <div className="flex justify-between text-gray-400 text-sm mt-2">
              <span>{formatTime(currentTime)}</span>
              <span>{formatTime(duration)}</span>
            </div>
          </div>

          {/* Playback Speed */}
          <div className="mb-6">
            <label className="text-gray-300 text-sm mb-2 block">Playback Speed: {playbackRate.toFixed(1)}x</label>
            <div className="flex items-center gap-2">
              <button
                onClick={() => adjustPlaybackRate(-0.1)}
                className="bg-gray-700 text-white px-3 py-1 rounded hover:bg-gray-600"
              >
                -0.1
              </button>
              <input
                type="range"
                min="0.1"
                max="3.0"
                step="0.1"
                value={playbackRate}
                onChange={(e) => setPlaybackRate(parseFloat(e.target.value))}
                className="flex-1"
              />
              <button
                onClick={() => adjustPlaybackRate(0.1)}
                className="bg-gray-700 text-white px-3 py-1 rounded hover:bg-gray-600"
              >
                +0.1
              </button>
            </div>
          </div>

          {/* Main Controls */}
          <div className="flex justify-center items-center gap-4 mb-6">
            <button
              onClick={previousTrack}
              className="bg-gray-700 p-3 rounded-full hover:bg-gray-600 transition"
              title="Previous Track (Triple click on headset)"
            >
              <SkipBack className="text-white" size={24} />
            </button>
            
            <button
              onClick={togglePlayPause}
              className="bg-purple-600 p-4 rounded-full hover:bg-purple-700 transition"
              disabled={playlist.length === 0}
              title="Play/Pause (Single click on headset)"
            >
              {isPlaying ? 
                <Pause className="text-white" size={32} /> : 
                <Play className="text-white" size={32} />
              }
            </button>
            
            <button
              onClick={skipForward}
              className="bg-gray-700 p-3 rounded-full hover:bg-gray-600 transition"
              title="Skip Forward 60s (Double click on headset)"
            >
              <SkipForward className="text-white" size={24} />
            </button>

            <button
              onClick={cycleLoopMode}
              className={`p-3 rounded-full transition ${
                loopMode !== 'none' ? 'bg-purple-600' : 'bg-gray-700'
              } hover:bg-purple-700`}
              title={`Loop: ${loopMode}`}
            >
              {loopMode === 'one' ? 
                <Repeat1 className="text-white" size={24} /> :
                <Repeat className="text-white" size={24} />
              }
            </button>
          </div>

          {/* Playlist Management */}
          <div className="flex gap-2 mb-6">
            <input
              ref={fileInputRef}
              type="file"
              accept="audio/*"
              multiple
              onChange={handleFileSelect}
              className="hidden"
              id="file-input"
            />
            <label
              htmlFor="file-input"
              className="flex-1 bg-purple-600 text-white py-3 rounded-lg cursor-pointer hover:bg-purple-700 transition flex items-center justify-center gap-2"
            >
              <Plus size={20} />
              Add Tracks
            </label>
            <button
              onClick={clearPlaylist}
              className="bg-red-600 text-white px-6 py-3 rounded-lg hover:bg-red-700 transition flex items-center gap-2"
            >
              <Trash2 size={20} />
              Clear
            </button>
          </div>

          {/* Playlist */}
          <div className="bg-gray-700 rounded-lg p-4 max-h-64 overflow-y-auto">
            <h3 className="text-white font-semibold mb-3">Playlist ({playlist.length})</h3>
            {playlist.length === 0 ? (
              <p className="text-gray-400 text-center py-4">No tracks in playlist</p>
            ) : (
              <ul className="space-y-2">
                {playlist.map((track, idx) => (
                  <li
                    key={idx}
                    className={`p-2 rounded cursor-pointer transition ${
                      idx === currentIndex ? 'bg-purple-600 text-white' : 'bg-gray-600 text-gray-200 hover:bg-gray-500'
                    }`}
                    onClick={() => setCurrentIndex(idx)}
                  >
                    <span className="text-sm">{idx + 1}. {track.name}</span>
                  </li>
                ))}
              </ul>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}
