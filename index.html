import React, { useState, useRef, useEffect } from 'react';
import { Play, Pause, SkipForward, SkipBack, Plus, Trash2, Repeat, Repeat1 } from 'lucide-react';

export default function AudioPlayer() {
  const [playlist, setPlaylist] = useState([]);
  const [currentIndex, setCurrentIndex] = useState(0);
  const [isPlaying, setIsPlaying] = useState(false);
  const [currentTime, setCurrentTime] = useState(0);
  const [duration, setDuration] = useState(0);
  const [playbackRate, setPlaybackRate] = useState(1.0);
  const [loopMode, setLoopMode] = useState('none');
  const [wakeLockStatus, setWakeLockStatus] = useState('Not active');
  
  const audioRef = useRef(null);
  const fileInputRef = useRef(null);
  const wakeLockRef = useRef(null);

  // Initialize audio element
  useEffect(() => {
    if (!audioRef.current) {
      const audio = document.createElement('audio');
      audio.preload = 'metadata';
      audioRef.current = audio;
      document.body.appendChild(audio);

      const handleTimeUpdate = () => setCurrentTime(audio.currentTime);
      const handleLoadedMetadata = () => setDuration(audio.duration);
      const handleEnded = () => handleTrackEnd();
      const handleCanPlay = () => {
        if (isPlaying) {
          audio.play().catch(err => console.log('Play error:', err));
        }
      };

      audio.addEventListener('timeupdate', handleTimeUpdate);
      audio.addEventListener('loadedmetadata', handleLoadedMetadata);
      audio.addEventListener('ended', handleEnded);
      audio.addEventListener('canplay', handleCanPlay);

      return () => {
        audio.removeEventListener('timeupdate', handleTimeUpdate);
        audio.removeEventListener('loadedmetadata', handleLoadedMetadata);
        audio.removeEventListener('ended', handleEnded);
        audio.removeEventListener('canplay', handleCanPlay);
        audio.pause();
        document.body.removeChild(audio);
      };
    }
  }, []);

  // Request wake lock when playing
  const requestWakeLock = async () => {
    if ('wakeLock' in navigator) {
      try {
        wakeLockRef.current = await navigator.wakeLock.request('screen');
        setWakeLockStatus('Active');
        
        wakeLockRef.current.addEventListener('release', () => {
          setWakeLockStatus('Released');
        });
      } catch (err) {
        setWakeLockStatus(`Error: ${err.message}`);
      }
    } else {
      setWakeLockStatus('Not supported');
    }
  };

  // Release wake lock when paused
  const releaseWakeLock = () => {
    if (wakeLockRef.current) {
      wakeLockRef.current.release();
      wakeLockRef.current = null;
    }
  };

  // Setup Media Session API
  useEffect(() => {
    if ('mediaSession' in navigator && playlist.length > 0 && playlist[currentIndex]) {
      const currentTrack = playlist[currentIndex];
      
      navigator.mediaSession.metadata = new MediaMetadata({
        title: currentTrack.name,
        artist: 'Audio Player',
        album: `Track ${currentIndex + 1} of ${playlist.length}`
      });

      navigator.mediaSession.setActionHandler('play', async () => {
        await togglePlayPause();
      });
      
      navigator.mediaSession.setActionHandler('pause', async () => {
        await togglePlayPause();
      });
      
      navigator.mediaSession.setActionHandler('seekforward', (details) => {
        const skipTime = details.seekOffset || 60;
        skipForward(skipTime);
      });
      
      navigator.mediaSession.setActionHandler('previoustrack', () => {
        previousTrack();
      });
      
      navigator.mediaSession.setActionHandler('nexttrack', () => {
        nextTrack();
      });

      // Update position state
      if (audioRef.current && !isNaN(duration) && duration > 0) {
        navigator.mediaSession.setPositionState({
          duration: duration,
          playbackRate: playbackRate,
          position: currentTime
        });
      }
    }

    return () => {
      if ('mediaSession' in navigator) {
        navigator.mediaSession.setActionHandler('play', null);
        navigator.mediaSession.setActionHandler('pause', null);
        navigator.mediaSession.setActionHandler('seekforward', null);
        navigator.mediaSession.setActionHandler('previoustrack', null);
        navigator.mediaSession.setActionHandler('nexttrack', null);
      }
    };
  }, [playlist, currentIndex, isPlaying, currentTime, duration, playbackRate]);

  // Load track
  useEffect(() => {
    if (playlist.length > 0 && audioRef.current && playlist[currentIndex]) {
      const track = playlist[currentIndex];
      const wasPlaying = isPlaying;
      
      audioRef.current.src = track.url;
      audioRef.current.playbackRate = playbackRate;
      audioRef.current.load();
      
      if (wasPlaying) {
        const playPromise = audioRef.current.play();
        if (playPromise !== undefined) {
          playPromise.catch(err => {
            console.log('Play interrupted:', err);
            setIsPlaying(false);
          });
        }
      }
    }
  }, [currentIndex, playlist]);

  // Update playback rate
  useEffect(() => {
    if (audioRef.current) {
      audioRef.current.playbackRate = playbackRate;
    }
  }, [playbackRate]);

  const handleFileSelect = (e) => {
    const files = Array.from(e.target.files);
    const newTracks = files.map(file => ({
      name: file.name,
      url: URL.createObjectURL(file),
      file: file
    }));
    
    setPlaylist(prev => {
      const updated = [...prev, ...newTracks];
      return updated;
    });
    
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  };

  const togglePlayPause = async () => {
    if (!audioRef.current || playlist.length === 0) return;
    
    if (isPlaying) {
      audioRef.current.pause();
      setIsPlaying(false);
      releaseWakeLock();
      
      if ('mediaSession' in navigator) {
        navigator.mediaSession.playbackState = 'paused';
      }
    } else {
      const playPromise = audioRef.current.play();
      if (playPromise !== undefined) {
        playPromise.then(() => {
          setIsPlaying(true);
          requestWakeLock();
          
          if ('mediaSession' in navigator) {
            navigator.mediaSession.playbackState = 'playing';
          }
        }).catch(err => {
          console.log('Play failed:', err);
          setIsPlaying(false);
        });
      }
    }
  };

  const skipForward = (seconds = 60) => {
    if (audioRef.current && duration > 0) {
      const newTime = Math.min(currentTime + seconds, duration);
      audioRef.current.currentTime = newTime;
      setCurrentTime(newTime);
    }
  };

  const previousTrack = () => {
    if (playlist.length === 0) return;
    
    const newIndex = currentIndex > 0 ? currentIndex - 1 : playlist.length - 1;
    setCurrentIndex(newIndex);
    setCurrentTime(0);
  };

  const nextTrack = () => {
    if (playlist.length === 0) return;
    
    const newIndex = (currentIndex + 1) % playlist.length;
    setCurrentIndex(newIndex);
    setCurrentTime(0);
  };

  const handleTrackEnd = () => {
    if (loopMode === 'one') {
      if (audioRef.current) {
        audioRef.current.currentTime = 0;
        audioRef.current.play();
      }
    } else if (loopMode === 'all') {
      nextTrack();
    } else if (currentIndex < playlist.length - 1) {
      nextTrack();
    } else {
      setIsPlaying(false);
      releaseWakeLock();
      if ('mediaSession' in navigator) {
        navigator.mediaSession.playbackState = 'paused';
      }
    }
  };

  const clearPlaylist = () => {
    if (audioRef.current) {
      audioRef.current.pause();
      audioRef.current.src = '';
    }
    
    playlist.forEach(track => {
      try {
        URL.revokeObjectURL(track.url);
      } catch (e) {
        console.log('Error revoking URL:', e);
      }
    });
    
    setPlaylist([]);
    setCurrentIndex(0);
    setIsPlaying(false);
    setCurrentTime(0);
    setDuration(0);
    releaseWakeLock();
  };

  const seekTo = (e) => {
    if (!audioRef.current || !duration) return;
    
    const rect = e.currentTarget.getBoundingClientRect();
    const percent = (e.clientX - rect.left) / rect.width;
    const newTime = percent * duration;
    audioRef.current.currentTime = newTime;
    setCurrentTime(newTime);
  };

  const cycleLoopMode = () => {
    const modes = ['none', 'one', 'all'];
    const currentIdx = modes.indexOf(loopMode);
    setLoopMode(modes[(currentIdx + 1) % modes.length]);
  };

  const formatTime = (seconds) => {
    if (isNaN(seconds) || seconds === 0) return '0:00';
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  const adjustPlaybackRate = (delta) => {
    setPlaybackRate(prev => Math.max(0.1, Math.min(3.0, Math.round((prev + delta) * 10) / 10)));
  };

  const selectTrack = (idx) => {
    setCurrentIndex(idx);
    setCurrentTime(0);
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-900 via-purple-900 to-gray-900 p-4">
      <div className="max-w-2xl mx-auto">
        <div className="bg-gray-800 rounded-lg shadow-2xl p-6">
          <h1 className="text-2xl md:text-3xl font-bold text-white mb-4 text-center">
            Audio Player <span className="text-sm text-gray-400">v1.1</span>
          </h1>

          {/* Current Track Info */}
          <div className="bg-gray-700 rounded-lg p-4 mb-4">
            <div className="text-center">
              <p className="text-gray-400 text-sm mb-1">Now Playing</p>
              <p className="text-white font-semibold truncate text-sm md:text-base">
                {playlist[currentIndex]?.name || 'No track selected'}
              </p>
              <p className="text-gray-400 text-xs mt-1">
                {playlist.length > 0 && `Track ${currentIndex + 1} of ${playlist.length}`}
              </p>
            </div>
          </div>

          {/* Progress Bar */}
          <div className="mb-4">
            <div 
              className="bg-gray-700 h-3 rounded-full cursor-pointer touch-manipulation"
              onClick={seekTo}
              onTouchEnd={seekTo}
            >
              <div 
                className="bg-purple-500 h-3 rounded-full transition-all"
                style={{ width: `${duration > 0 ? (currentTime / duration) * 100 : 0}%` }}
              />
            </div>
            <div className="flex justify-between text-gray-400 text-sm mt-2">
              <span>{formatTime(currentTime)}</span>
              <span>{formatTime(duration)}</span>
            </div>
          </div>

          {/* Playback Speed */}
          <div className="mb-4">
            <label className="text-gray-300 text-sm mb-2 block">
              Speed: {playbackRate.toFixed(1)}x
            </label>
            <div className="flex items-center gap-2">
              <button
                onClick={() => adjustPlaybackRate(-0.1)}
                className="bg-gray-700 text-white px-3 py-2 rounded hover:bg-gray-600 active:bg-gray-500 text-sm touch-manipulation"
              >
                -0.1
              </button>
              <input
                type="range"
                min="0.1"
                max="3.0"
                step="0.1"
                value={playbackRate}
                onChange={(e) => setPlaybackRate(parseFloat(e.target.value))}
                className="flex-1 touch-manipulation"
              />
              <button
                onClick={() => adjustPlaybackRate(0.1)}
                className="bg-gray-700 text-white px-3 py-2 rounded hover:bg-gray-600 active:bg-gray-500 text-sm touch-manipulation"
              >
                +0.1
              </button>
            </div>
          </div>

          {/* Main Controls */}
          <div className="flex justify-center items-center gap-3 mb-4">
            <button
              onClick={previousTrack}
              className="bg-gray-700 p-3 rounded-full hover:bg-gray-600 active:bg-gray-500 transition touch-manipulation"
              title="Previous Track"
            >
              <SkipBack className="text-white" size={20} />
            </button>
            
            <button
              onClick={togglePlayPause}
              className="bg-purple-600 p-4 rounded-full hover:bg-purple-700 active:bg-purple-800 transition touch-manipulation"
              disabled={playlist.length === 0}
              title="Play/Pause"
            >
              {isPlaying ? 
                <Pause className="text-white" size={28} /> : 
                <Play className="text-white" size={28} />
              }
            </button>
            
            <button
              onClick={() => skipForward(60)}
              className="bg-gray-700 p-3 rounded-full hover:bg-gray-600 active:bg-gray-500 transition touch-manipulation"
              title="Skip Forward 60s"
            >
              <SkipForward className="text-white" size={20} />
            </button>

            <button
              onClick={cycleLoopMode}
              className={`p-3 rounded-full transition touch-manipulation ${
                loopMode !== 'none' ? 'bg-purple-600 hover:bg-purple-700' : 'bg-gray-700 hover:bg-gray-600'
              } active:opacity-75`}
              title={`Loop: ${loopMode}`}
            >
              {loopMode === 'one' ? 
                <Repeat1 className="text-white" size={20} /> :
                <Repeat className="text-white" size={20} />
              }
            </button>
          </div>

          {/* Playlist Management */}
          <div className="flex gap-2 mb-4">
            <input
              ref={fileInputRef}
              type="file"
              accept="audio/*"
              multiple
              onChange={handleFileSelect}
              className="hidden"
              id="file-input"
            />
            <label
              htmlFor="file-input"
              className="flex-1 bg-purple-600 text-white py-3 rounded-lg cursor-pointer hover:bg-purple-700 active:bg-purple-800 transition flex items-center justify-center gap-2 text-sm md:text-base touch-manipulation"
            >
              <Plus size={18} />
              Add Tracks
            </label>
            <button
              onClick={clearPlaylist}
              className="bg-red-600 text-white px-4 md:px-6 py-3 rounded-lg hover:bg-red-700 active:bg-red-800 transition flex items-center gap-2 text-sm md:text-base touch-manipulation"
            >
              <Trash2 size={18} />
              Clear
            </button>
          </div>

          {/* Playlist */}
          <div className="bg-gray-700 rounded-lg p-4 max-h-64 overflow-y-auto">
            <h3 className="text-white font-semibold mb-3 text-sm md:text-base">
              Playlist ({playlist.length})
            </h3>
            {playlist.length === 0 ? (
              <p className="text-gray-400 text-center py-4 text-sm">No tracks in playlist</p>
            ) : (
              <ul className="space-y-2">
                {playlist.map((track, idx) => (
                  <li
                    key={idx}
                    className={`p-2 rounded cursor-pointer transition touch-manipulation text-sm ${
                      idx === currentIndex 
                        ? 'bg-purple-600 text-white' 
                        : 'bg-gray-600 text-gray-200 hover:bg-gray-500 active:bg-gray-400'
                    }`}
                    onClick={() => selectTrack(idx)}
                  >
                    {idx + 1}. {track.name}
                  </li>
                ))}
              </ul>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}
